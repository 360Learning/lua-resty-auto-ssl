#!/usr/bin/env bash

sock_file=/tmp/shell.sock
pid_file=/tmp/auto-ssl-sockproc.pid

# We want to launch sockproc from inside nginx using os.execute (mainly just to
# simplify the deployment of auto-ssl, so you don't have to worry about running
# sockproc). But we need to clear the file descriptors we pass to sockproc, or
# else when nginx is stopped, sockproc inherits the port nginx was listening to,
# and then sockproc holds that port open, preventing nginx from starting
# again.
#
# This wipes any file descriptors > 2 that nginx might pass along (so only
# stdin, stdout, and stderr are retained).
#
# See:
# http://stackoverflow.com/a/4839945/222487
# http://stackoverflow.com/a/23104923/222487
if [ -d /proc ]; then
  current_pid=$BASHPID
  file_descriptors=$(find /proc/$current_pid/fd -type l -exec basename {} ';')
  for fd in $file_descriptors; do
    if ((fd > 2)); then
      eval "exec $fd>&-"
    fi
  done

# If /proc isn't supported (eg, OS X), fallback to a simpler, naive mechanism
# to wipe file descriptors > 2.
else
  END=255
  for ((fd=3; fd <= END; fd++)); do
    eval "exec $fd>&-"
  done
fi

# When nginx shuts down, the sockproc daemon continues to run. So when nginx
# subsequently starts again, we'll also make sure we restart sockproc.
if [ -e "$pid_file" ]; then
  PID=$(cat "$pid_file")
  kill "$PID" || true
fi

# Just make sure the socket file is cleaned up.
rm -f "$sock_file" || true

# Start the sockproc daemon.
bin_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
"$bin_dir"/sockproc "$sock_file" "$pid_file"
