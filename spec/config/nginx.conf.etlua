master_process <%- master_process or "off" %>;
worker_processes <%- worker_processes or "1" %>;
user <%- user %>;
daemon off;
pid <%- current_test_dir %>/nginx.pid;
error_log <%- current_test_dir %>/error.log debug;

events {
  worker_connections 1024;
}

http {
  access_log <%- current_test_dir %>/access.log combined;

  resolver ipv6=off local=on;
  lua_shared_dict auto_ssl 1m;
  <% if not disable_auto_ssl_settings_dict then %>
    lua_shared_dict auto_ssl_settings 64k;
  <% end %>

  init_by_lua_block {
    ngx.log(ngx.NOTICE, "init_by_lua_block")

    local options = {
      dir = "<%- current_test_dir %>/auto-ssl",
      ca = "https://acme-staging.api.letsencrypt.org/directory",
      allow_domain = function(domain)
        return true
      end,
    }
    <%- auto_ssl_pre_new or "" %>
    auto_ssl = (require "resty.auto-ssl").new(options)
    <%- auto_ssl_post_new or "" %>
    auto_ssl:init()
  }

  init_worker_by_lua_block {
    auto_ssl:init_worker()
  }

  server {
    listen 9443 ssl;
    ssl_certificate <%- root_dir %>/t/certs/example_fallback.crt;
    ssl_certificate_key <%- root_dir %>/t/certs/example_fallback.key;
    ssl_certificate_by_lua_block {
      auto_ssl:ssl_certificate()
    }

    location /foo {
      server_tokens off;
      echo -n "foo";
    }
  }

  server {
    listen 9444 ssl;
    ssl_certificate <%- root_dir %>/t/certs/example_fallback.crt;
    ssl_certificate_key <%- root_dir %>/t/certs/example_fallback.key;
    ssl_certificate_by_lua_block {
      auto_ssl:ssl_certificate({
        generate_certs = false,
      })
    }

    location /foo {
      server_tokens off;
      echo -n "generate_certs = false server";
    }
  }

  server {
    listen 9080;
    location /.well-known/acme-challenge/ {
      content_by_lua_block {
        auto_ssl:challenge_server()
      }
    }

    location /hook-server-secret {
      content_by_lua_block {
        ngx.print(ngx.shared.auto_ssl_settings:get("hook_server:secret"))
      }
    }

    location /auto-ssl-init {
      content_by_lua_block {
        auto_ssl:init()
        ngx.print("init")
      }
    }

    location /fill-auto-ssl-shdict {
      content_by_lua_block {
        local cjson = require "cjson.safe"
        local resty_random = require "resty.random"
        local str = require "resty.string"

        -- Fill the shdict with random things to simulate what happens when old
        -- data gets forced out.
        for i = 1, 15 do
          local random = resty_random.bytes(256000)
          local _, err = ngx.shared.auto_ssl:set("foobar" .. i, str.to_hex(random))
          if err then
            ngx.log(ngx.ERR, "set error: ", err)
            return ngx.exit(500)
          end
        end

        -- Ensure items are getting forced out as expected, after filling it up.
        local random = resty_random.bytes(256000)
        local _, err, forcible = ngx.shared.auto_ssl:set("foobar-force", str.to_hex(random))
        if err then
          ngx.log(ngx.ERR, "set error: ", err)
          return ngx.exit(500)
        end
        if not forcible then
          ngx.log(ngx.ERR, "set didn't force other items out of shdict, as expected")
          return ngx.exit(500)
        end

        ngx.print(cjson.encode({
          keys = #ngx.shared.auto_ssl:get_keys(),
        }))
      }
    }

    location /flush-auto-ssl-shdict {
      content_by_lua_block {
        local cjson = require "cjson.safe"

        -- Completely wipe certs from storage, to simulate a new registration
        -- after completely running out of memory.
        ngx.shared.auto_ssl:flush_all()

        ngx.print(cjson.encode({
          keys = #ngx.shared.auto_ssl:get_keys(),
        }))
      }
    }

    location /get-lua-root {
      content_by_lua_block {
        local cjson = require "cjson.safe"
        ngx.print(cjson.encode({
          lua_root = auto_ssl.lua_root,
        }))
      }
    }
  }

  server {
    listen 127.0.0.1:8999;
    client_body_buffer_size <%- hook_server and hook_server.client_body_buffer_size or "128k" %>;
    client_max_body_size <%- hook_server and hook_server.client_max_body_size or "128k" %>;
    location / {
      content_by_lua_block {
        auto_ssl:hook_server()
      }
    }
  }
}
